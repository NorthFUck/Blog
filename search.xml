<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java</title>
      <link href="/2022/06/21/java/"/>
      <url>/2022/06/21/java/</url>
      
        <content type="html"><![CDATA[<h2 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h2><h3 id="1-简介："><a href="#1-简介：" class="headerlink" title="1. 简介："></a>1. 简介：</h3><ul><li><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出，后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p><ul><li>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME</li></ul></li><li><h4 id="Java体系"><a href="#Java体系" class="headerlink" title="Java体系"></a>Java体系</h4><ul><li>JavaSE( java 平台标准版)</li><li>JavaEE( java 平台企业版)</li><li>JavaME(Java 平台微型版)</li></ul></li></ul><h3 id="2-Java特性"><a href="#2-Java特性" class="headerlink" title="2.Java特性"></a>2.Java特性</h3><ul><li>Java 语言是简单的</li><li>Java 语言是面向对象的</li><li>Java 语言是分布式的</li><li>Java 语言是健壮的</li><li>Java 语言是安全的</li><li>Java语言是体系结构中立的</li><li>Java 语言是可移植的</li><li>Java 语言是解释型的</li><li>Java 是高性能的</li><li>Java 语言是多线程的</li><li>Java 语言是动态的</li></ul><h2 id="Java开发环境配置"><a href="#Java开发环境配置" class="headerlink" title="Java开发环境配置"></a>Java开发环境配置</h2><ul><li><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>jvm  c++</p><p>跨平台</p><p>9 10</p><h3 id="下载地址：https-www-oracle-com-java-technologies-javase-javase9-archive-downloads-html"><a href="#下载地址：https-www-oracle-com-java-technologies-javase-javase9-archive-downloads-html" class="headerlink" title="下载地址：https://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html"></a>下载地址：<a href="https://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html</a></h3><h3 id="jdk？jre？jvm？"><a href="#jdk？jre？jvm？" class="headerlink" title="jdk？jre？jvm？"></a>jdk？jre？jvm？</h3><p>Java development kit             java开发工具包  jdk</p><p>Java Runtime Environment  java运行环境  jre</p><p>Java Virtual Machine              java虚拟机  jvm</p><h3 id="jdk安装方法：以下可以用来复制粘贴"><a href="#jdk安装方法：以下可以用来复制粘贴" class="headerlink" title="jdk安装方法：以下可以用来复制粘贴"></a>jdk安装方法：以下可以用来复制粘贴</h3><h2 id="1-新建系统变量：JAVA-HOME"><a href="#1-新建系统变量：JAVA-HOME" class="headerlink" title="1.新建系统变量：JAVA_HOME"></a>1.新建系统变量：JAVA_HOME</h2><p>路径取jdk路径</p><p><strong>E:\xxx\jdk1.8</strong></p><h2 id="2-在系统变量Path后面追加"><a href="#2-在系统变量Path后面追加" class="headerlink" title="2.在系统变量Path后面追加"></a>2.在系统变量Path后面追加</h2><p>%JAVA_HOME%\bin</p><p>%JAVA_HOME%\jre\bin</p><h2 id="3-添加classpath"><a href="#3-添加classpath" class="headerlink" title="3. 添加classpath"></a>3. 添加classpath</h2><p>CLASSPATH</p><p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</p><h2 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h2><p>Microsoft Windows [版本 10.0.18363.592]</p><p>(c) 2019 Microsoft Corporation。保留所有权利。</p><p>C:\Users\frank&gt;javac -version</p><p>javac 1.8.0_241</p><p>C:\Users\frank&gt;</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>InterlliJ IDEA</p><h3 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a><a href="http://www.baidu.com/link?url=i3i-6XPbHB26Aq9yMM7lcAAUerW_VLc1Jp2sOrIHM2nFcws9j0LFvj4aoaQrc1xG"><em>JetBrains</em></a></h3><p><a href="https://cloud.189.cn/t/QZZjymIVVzuu">https://cloud.189.cn/t/QZZjymIVVzuu</a> (访问码:5ekw)</p></li></ul><h2 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><ul><li>一个Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作</li><li>对象</li><li>类</li><li>方法</li><li>实例变量</li></ul><ol><li><p>Java是怎样执行的 ？ 说好的exe 文件呢？</p><table><thead><tr><th>JAVA</th><th>C</th></tr></thead><tbody><tr><td>java执行时会生成<code>.class</code>文件</td><td>C执行的时候会生成<code>.exe</code>文件（win）</td></tr><tr><td>java要运行必须有jdk、jre和jvm</td><td>C执行的时候不需要这些文件</td></tr><tr><td>java<code>.class</code>跨平台效果好</td><td>C<code>.exe</code>跨平台效果不好（win）</td></tr></tbody></table><ul><li><strong>jdk(Java Development Kit)：</strong> java程序开发工具包</li><li><strong>jre(Java runtime environment)：</strong> java运行环境</li><li><strong>jvm(Java Virtual Machine)：</strong> java虚拟机</li></ul></li></ol><ul><li><p>使用idea 编写Java程序时注意：</p><ul><li><p><strong>package</strong><br>Java package 如同文件夹一样，工程文件主要分为idea、out、src、web四个大包</p><p><strong>1.idea文件夹</strong></p><p>.idea存放项目的配置信息，包括历史记录，版本控制信息等<br><strong>2.iml文件夹</strong></p><p>iml(infomation of module)是IntelliJ IDEA 自动创建的模块文件</p><p>用于Java应用开发，存储一些模块开发相关的信息，还可能会存储一 些模块路径信息， 依赖信息以及别的一些设置</p><p><strong>3.src文件夹</strong></p><p>即source，存放的是项目的源文件(.java后缀与配置文件)</p><p>分成几个包的目的：对代码的优化、实现高聚合、低耦合特点、便于以后的扩展和更改</p><p><strong>4.External Libraries</strong></p><p>Java外部库<br><strong>5.Scratches and Consoles</strong></p><p>Intellij IDEA 提供了两种临时的文件编辑环境，两种 Scratches 分别是Scratch files 和 Scratch buffers<br>Scratch files ：Scratch files 有着完整的运行和 debug 功能等等，这些文件需要指定编程语言类型并且指定后缀。<br>Scratch buffers : Scratch buffers仅仅是为了简单的编辑记录，所以不需要指定编程语言并且指定后缀，默认文件类型是 .txt。需要注意的是，Scratch buffers最多只能创建 5 个，超过 5 个将开始重用以前的，并且以前文件的内容会被重置。</p></li><li><p>项目视图</p><ul><li>默认是将package层级以简洁显示的,非精简模式<ul><li><img src="https://img-blog.csdnimg.cn/17627d177f4f4b8c93bd3bd6627f063e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWWVhdHNfTGlhbw==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li><li>对packages单击右键，点击Compact Middle Packages即可切换成精简模式<ul><li><img src="https://img-blog.csdnimg.cn/7fd52a8d1e4f4990bbf4b1c57d87afc3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWWVhdHNfTGlhbw==,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li><img src="https://img-blog.csdnimg.cn/31f5b3c4d4ad4989bbd35b3e0491b497.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWWVhdHNfTGlhbw==,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul></li></ul></li></ul><h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><ul><li>注意事项<ul><li>大小写敏感</li><li>类名</li><li>方法名</li><li>源文件名</li><li>主方法入口</li></ul></li><li>Java 标识符</li><li>Java 修饰符</li><li>Java 变量</li><li>Java 数组</li><li>Java 变量</li><li>Java 枚举</li><li>Java 关键字</li><li>Java 注释</li><li>Java 空行</li><li>继承</li><li>接口</li><li>Java 源程序 与 编译型运行区别<ul><li><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png" alt="img"></li></ul></li></ul><h4 id="1-Java-第一个程序讲解"><a href="#1-Java-第一个程序讲解" class="headerlink" title="1.Java 第一个程序讲解"></a>1.Java 第一个程序讲解</h4><ul><li><p>程序演示</p><ul><li><p>```java<br>package com.microsoft.demo; //定位你的Java代码放在src文件夹下的位置</p><p>//公共的  类   类名（开头字母必须大写和文件名相同）<br>public class Main{ </p><pre><code>//mian函数的固定格式public static void main(String[] args)&#123;        //语句    System.out.println(&quot;Hello&quot;);&#125;//java函数public static int sum(int number_a,int number_b)&#123;    return number_a+number_&#125;//函数的调用和C是一样的</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">- Java 注释和文档  - **基本注释**    - 和C语言一样有单行注释和段落注释    - 单行注释 &#96;&#x2F;&#x2F; ……&#96;    - 多行注释 &#96;&#x2F;* ...... *&#x2F;&#96; 注释内容不会出现在javadoc 生成的文档中  - **方法注释和类注释**    - 即文档注释 : &#x2F;** ...... *&#x2F; 注释内容写入javadoc生成的文档    - 注释格式&#x2F;** ...... *&#x2F;里面的内容有介绍函数，还有方法中用到的参数和返回值    - 这个可以快速生成一个方法文档（想要生成文档可以在快捷键里查doc）    - IntelliJ IDEA 里查看一个函数注释的方法是 ctrl+q- **一带而过**  - **参照菜鸟教程**    - Java 基本数据类型    - Java修饰符    - Java运算符  - **自动类型转换**    - &#96;&#96;&#96;java      低  ------------------------------------&gt;  高            byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>数据类型转换满足规则</strong></p><ul><li><p>\1. 不能对boolean类型进行类型转换。</p></li><li><p>\2. 不能把对象类型转换成不相关类的对象。</p></li><li><p>\3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>\4. 转换过程中可能导致溢出或损失精度</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p><ul><li>```java<br>(int)23.7 == 23;<br>(int)-45.89f == -45<pre class="line-numbers language-none"><code class="language-none">- 强制类型转换  - 条件是转换的数据类型必须是兼容的  - 格式：(type)value type是要强制类型转换后的数据类型     - &#96;&#96;&#96;java      public class QiangZhiZhuanHuan&#123;          public static void main(String[] args)&#123;              int i1 &#x3D; 123;              byte b &#x3D; (byte)i1;&#x2F;&#x2F;强制类型转换为byte              System.out.println(&quot;int强制类型转换为byte后的值等于&quot;+b);          &#125;      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><p>import 导包和ＡＰＩ文档</p><ul><li><p>对比C和Java静态数组定义方式</p><ul><li><table><thead><tr><th>定义方式</th><th>Java</th><th>C</th></tr></thead><tbody><tr><td>初始化法</td><td><code>int[ ] arr =&#123;1,2,3&#125;</code></td><td><code>int arr [] = &#123;1,2,3&#125;</code></td></tr><tr><td>分配空间法</td><td><code>Type[] arr=new Type[size]</code></td><td><code>int arr[size]</code></td></tr></tbody></table></li><li><p>普通的静态数组有缺陷：长度是固定的，不能扩容，没有灵活性</p></li></ul></li><li><p>注意： <strong>String的length带括号，数组里的length不带括号</strong></p><ul><li>```java<br>str.length();<br>arr.length;<pre class="line-numbers language-none"><code class="language-none">- 增强 for 循环  - &#96;&#96;&#96;java    for (int i: arr_2) &#123;         System.out.println(arr_2[i]);    &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul></li></ul><h4 id="2-Arrays"><a href="#2-Arrays" class="headerlink" title="2.Arrays"></a>2.Arrays</h4><ul><li><p>Arrays 提供许多方法</p><ul><li><p>如：sort() 排序</p><ul><li>```java<br>int[] arr_1 = {1, 2, 3, 6, 7, 8,111,1111,112,1235,123};<pre><code>    Arrays.sort(arr_1);    for (int element:arr_1) &#123;        System.out.print(element + &quot; &quot;);    &#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">#### 3.函数和方法- 什么是方法？  - Java方法是语句的集合，它们在一起执行一个功能  - 方法和C里的函数是一模一样的  - 具体参照菜鸟教程#### 4.方法的重载- 方法名相同，参数个数或这参数类型不同  - &#96;&#96;&#96;java    package com.microsoft.demo;    import java.util.Arrays;    public class main &#123;        public static void main(String[] args) &#123;            int sum &#x3D; sum(1, 2);            double value &#x3D; sum(1.2 , 3.4);            System.out.println(&quot;sum &#x3D; &quot; + sum);            System.out.println(&quot;value &#x3D; &quot; + value);        &#125;        public static int sum (int x, int y)&#123;            return x + y;        &#125;        public static double sum ( double x, double y)&#123;            return x + y;        &#125;    &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><h4 id="5-约束规范"><a href="#5-约束规范" class="headerlink" title="5.约束规范"></a>5.约束规范</h4><ul><li>具体参照阿里开发手册</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><ul><li><p>泛指把前人的作风、文化、知识等接受过来</p></li><li><p>把重复的代码放在一块，让其他的动物接受过来，这也是一种继承</p></li><li><p>我可以创造一个类叫”动物”，这样其他的动物都可以在”动物”类中继承相同的地方，继承的关键词是 extends</p><ul><li>代码演示<ul><li><img src="https://img-blog.csdnimg.cn/988b2c3e8b1f44f4b89f5f3cad5d6e9a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWWVhdHNfTGlhbw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul></li></ul></li><li><p>我们把原来属于Dogs的内容转移到了Animal中，使用 extends ，最后在主函数中像之前一样Dogs类</p></li><li><p>并且 Cat在继承Pet以后也可以像狗一样实践，这样就使得我们的代码的复用性很强，也符合了大众化</p></li><li><h4 id="饿狼传说之多继承"><a href="#饿狼传说之多继承" class="headerlink" title="饿狼传说之多继承"></a>饿狼传说之多继承</h4><ul><li><p>像灰太狼家族，一层一层的继承，爷爷传承到爸爸、爸爸传承到孙子</p></li><li><p>一个类不能直接继承多个类，java是单继承语言，不支持多继承</p></li><li><p>不能写成 class A extends B,C</p></li><li><p>但可以实现继承多个类 class A extends B，class C extends A 这样C就同时继承了B和A两个类了</p><ul><li>```java<br>public class Dogs extends Animal{<br>}<pre class="line-numbers language-none"><code class="language-none">- &#96;&#96;&#96;java  public class Labrador extends Dogs &#123;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><h4 id="super-啃老"><a href="#super-啃老" class="headerlink" title="super 啃老"></a>super 啃老</h4></li></ul><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><ul><li>封装的概念<ul><li>将类的某些<a href="https://so.csdn.net/so/search?q=%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F&spm=1001.2101.3001.7020">信息隐藏</a>在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来对隐藏的信息进行操作和访问</li></ul></li><li>封装的好处<ul><li>只能通过规定的方法访问数据</li><li>隐藏类的实例细节，方便修改和实现。</li></ul></li><li>封装的实现步骤<ul><li>修改属性的可见性设为（<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>）</li><li>创建getter/setter方法（用于属性的读写）（通过这两种方法对数据进行获取和设定，对象通过调用这两种发方法实现对数据的读写）</li><li>在getter/setter方法中加入属性控制语句（对属性值的合法性进行判断）</li></ul></li></ul><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><h3 id="4-问题的产生和引导"><a href="#4-问题的产生和引导" class="headerlink" title="4.问题的产生和引导"></a>4.问题的产生和引导</h3><h5 id="假设有一个养狗的系统"><a href="#假设有一个养狗的系统" class="headerlink" title="假设有一个养狗的系统"></a>假设有一个养狗的系统</h5><ul><li><table><thead><tr><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>流水线</td><td>模块化</td></tr><tr><td>一件事”该怎么做”</td><td>一件事”该让谁来做”</td></tr><tr><td>狗饿了，狗吃了食物</td><td>属性:狗、食物、饿；动作:狗吃食物</td></tr><tr><td>强调的是“吃”，“狗”只是一个参数</td><td>强调的是“狗”，“吃”只是一个动作</td></tr></tbody></table></li><li><p>一件事“该让谁来做”，那个“谁”就是对象，他要怎么做是他自己的事，最后一群对象合力能把事做好了</p></li><li><p>相关笔记参照 CSDN</p></li><li><h5 id="多态，编译看左边，运行看右边"><a href="#多态，编译看左边，运行看右边" class="headerlink" title="多态，编译看左边，运行看右边"></a>多态，编译看左边，运行看右边</h5></li></ul><h3 id="5-静态方法"><a href="#5-静态方法" class="headerlink" title="5.静态方法"></a>5.静态方法</h3><ul><li><p>静态变量</p><ul><li>```java<pre><code>public static String plot =&quot;NanG&quot;;</code></pre><pre class="line-numbers language-none"><code class="language-none">    - 静态方法  - &#96;&#96;&#96;java        public static void goplot()&#123;            System.out.println(&quot;所有狗都进了小区&quot;);        &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>static 单例模式</p><ul><li><p>单例模式怎么来的？</p><ul><li>private static定义变量和方法只能在有类名来使用，可以看作是所有类都必须做的事情，而对象无法使用，对象无权选择或者不</li><li>选择，这里就衍生出了一种设计模式：单例模式</li></ul></li><li><p>单例模式怎么用？</p><ul><li>单例模式的存在是为了保证一个类仅有一个实例，无法克隆，并提供一个访问它的全局访问点</li></ul></li><li><p>下面就拿课程Frank讲的例子来理解一下</p><ul><li><p>```java<br>public class Earth {</p><pre><code>//new 一个新的地球，只有Earth类内可以调用private static Earth earthInstance = new Earth();//外部无法new新的Earthprivate Earth()&#123;&#125;//Earth在外部得到Earthpublic static Earth getEarthInstance()&#123;    return earthInstance;&#125;</code></pre><p>   public void showMessage(){</p><pre><code>  System.out.println(&quot;Hello Earth!&quot;);</code></pre><p>   }<br>}</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;javapublic class main &#123;   public static void main(String[] args) &#123;       &#x2F;&#x2F;不合法的构造函数      &#x2F;&#x2F;编译时错误：构造函数 Earth() 是不可见的      &#x2F;&#x2F;Earth object &#x3D; new Earth();       &#x2F;&#x2F;获取唯一可用的对象      Earth object &#x3D; Earth.getEarthInstance();       &#x2F;&#x2F;显示消息      object.showMessage();   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行结果</p><ul><li>```java<br>“Hello Earth!”<pre class="line-numbers language-none"><code class="language-none">### 6.内部类扯淡系列- 内部类是啥  - 类里面再来个类  - 静态内部类只能用静态变量  - 方法内部类，只能在方法里面用  - 用的比较少，十分难维护，可以自己去了解### 7.方法的重写- **如果要对继承中某个方法进行修改怎么办？**- 在类继承了另外一类，但是对一些方法需要进行修改的时候就需要用到方法的重写，比如动物的叫声不同- 方法的重写只有在继承中才能实现  - &#96;&#96;&#96;java        @Override        public void breaking() &#123;    &#x2F;&#x2F;        super.breaking();            System.out.println(&quot;喵喵&quot;);        &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><p>```java</p><pre><code>@Overridepublic void breaking() &#123;</code></pre><p>//        super.breaking();</p><pre><code>    System.out.println(&quot;汪汪&quot;);&#125;</code></pre><pre class="line-numbers language-none"><code class="language-none">  - 动物叫，这是它自己拥有的特性，是他自己写的，不是来自他爸的，他从爸爸那革新了  - 子类自己认为，应该打破它父亲的传统，进行革新，革新的内容就是方法体  - super 这个函数是继承父类的所有方法，如果要改写就需要将这个注释掉- **重写(Override)与重载(Overload)的区别是啥？**  - 重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变  - 重载(Overload)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同### 8.final- 遗产没人继承了，也不可能继承–final  - 例如我们创建一个拉布拉多类继承Dogs类，并用final定义- #### **用final定义的类不能再被继承**，相当于一个常量- ##### 用fianl定义的方法不能再被重写- ##### 用final定义的变量是常量且不能再被修改- ##### 方法也有重写，拿狗是否能导航来举例，Dogs类不加final结果：  - &#96;&#96;&#96;java        public boolean isGudieBlindness()&#123;            return false;        &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>用final定义的变量是常理，而在命令规范中，常理必须大写，单词用下划线隔开</p><ul><li><pre><code class="java">    private static final String COMMUNITY_NAME =&quot;NanG&quot;;    public static String getCommunityName()&#123;        return COMMUNITY_NAME;    &#125;</code></pre></li><li><p>idea快捷键<br><code>ctrl +shift+u</code>一键大写<br><code>shift+f6</code>一键更改变量</p></li></ul></li></ul><h3 id="9-抽象"><a href="#9-抽象" class="headerlink" title="9.抽象"></a>9.抽象</h3><h3 id="10-接口"><a href="#10-接口" class="headerlink" title="10.接口"></a>10.接口</h3><ul><li><p>接口只能实现</p></li><li><p>关键字 implements ， interface</p></li><li><h5 id="class与interfa的哲学气息"><a href="#class与interfa的哲学气息" class="headerlink" title="class与interfa的哲学气息"></a>class与interfa的哲学气息</h5><ul><li>区别<ul><li>抽象类是针对具体的事物进行抽象</li><li>接口是针对动作，行为进行抽象，且接口中避免出现名词</li></ul></li></ul></li></ul><h3 id="11，匿名内部类"><a href="#11，匿名内部类" class="headerlink" title="11，匿名内部类"></a>11，匿名内部类</h3><h3 id="12-权限修饰符"><a href="#12-权限修饰符" class="headerlink" title="12.权限修饰符"></a>12.权限修饰符</h3><h3 id="13-Object"><a href="#13-Object" class="headerlink" title="13.Object"></a>13.Object</h3><ul><li>Java Object 类是所有类的父类， Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法</li><li>我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类</li></ul><h2 id="Base-API"><a href="#Base-API" class="headerlink" title="Base API"></a>Base API</h2><h2 id="unit-test-and-main-function"><a href="#unit-test-and-main-function" class="headerlink" title="unit test and main function"></a>unit test and main function</h2><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><h3 id="1-异常的介绍"><a href="#1-异常的介绍" class="headerlink" title="1.异常的介绍"></a>1.异常的介绍</h3><h2 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h2><h3 id="1-问题的提出"><a href="#1-问题的提出" class="headerlink" title="1.问题的提出"></a>1.问题的提出</h3><ul><li>为什么一台电脑可以左很多事情？</li><li>一台计算机为何能够执行对个程序？ 它们是怎样执行多个程序的？<ul><li>第一，先理解现在的电脑，现在的电脑是</li><li>一台电脑可以做很多事情，一边聊天，一边听歌，一边上网查资料</li><li>而可以做到这样的原因是电脑有多个核心（脑子） ，一个核心可以做一个事情的话，那很多个核心就可以做 很多个事情</li><li>而多线程就是一台电脑（CPU） 的情况下，可以同时运行两个程序（表面上）</li><li>事实上是进程切换的块，第一个进程打开，第二个进程挂起，给你一种错觉</li></ul></li></ul><h3 id="2-核心数，进程，线程"><a href="#2-核心数，进程，线程" class="headerlink" title="2.核心数，进程，线程"></a>2.核心数，进程，线程</h3><ul><li>一个核心下有多个进程，而一个进程下又有多个线程</li></ul><h2 id="Java-collections-framework-Java集合框架"><a href="#Java-collections-framework-Java集合框架" class="headerlink" title="Java collections framework(Java集合框架)"></a>Java collections framework(Java集合框架)</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的诞生</title>
      <link href="/2022/06/21/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
      <url>/2022/06/21/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>相遇皆是缘分</p><h3 id="为什么建博客？"><a href="#为什么建博客？" class="headerlink" title="为什么建博客？"></a>为什么建博客？</h3><p>肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛!</p><h3 id="展望博客"><a href="#展望博客" class="headerlink" title="展望博客"></a>展望博客</h3><p>我会整理一些个人所学的知识（学前端的，也会捣鼓捣鼓一些其它的专业的知识）或生活方面有兴趣的事发到博客上供大家观摩</p><h3 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h3><p>有位可爱的（小）朋友，给我取名叫 “仙气”，这是也是我博客上自居 “仙气” 的由来。喜欢自己所喜欢的，做自己想做的，追求自由与潇洒，多酷啊！ 想法是美好的，可现实… …   给大家推荐一首诗吧</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 《自由与爱情》---作者:裴多菲​ 生命诚可贵​ 爱情价更高​ 若为自由故​ 二者皆可抛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>溜溜球啦！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/21/hello-world/"/>
      <url>/2022/06/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
